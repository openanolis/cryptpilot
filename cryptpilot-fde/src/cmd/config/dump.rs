use std::path::PathBuf;

use anyhow::Result;
use async_trait::async_trait;
use futures::StreamExt;

use crate::{
    config::cloud_init::CLOUD_INIT_FDE_CONFIG_BUNDLE_HEADER,
    disk::{
        artifacts::BootArtifacts, current::OnCurrentSystemFdeDisk, external::OnExternalFdeDisk,
        BootArtifactsType, FdeDisk,
    },
};

pub struct ConfigDumpCommand {
    pub disk: Option<PathBuf>,
}

#[async_trait]
impl super::super::Command for ConfigDumpCommand {
    async fn run(&self) -> Result<()> {
        tracing::debug!("Collecting boot related artifacts");

        let fde_disk: Box<dyn FdeDisk + Send + Sync> = match &self.disk {
            Some(disk) => Box::new(OnExternalFdeDisk::new_from_disk(disk).await?),
            None => Box::new(OnCurrentSystemFdeDisk::new().await?),
        };

        let boot_artifacts = fde_disk.extract_boot_artifacts().await?;
        tracing::debug!("Starting to extract cryptpilot fde config");

        let kernel_artifacts = match boot_artifacts {
            BootArtifactsType::Grub(grub_boot_artifacts) => {
                grub_boot_artifacts.extract_kernel_artifacts().await?
            }
            BootArtifactsType::Uki(uki_boot_artifacts) => {
                uki_boot_artifacts.extract_kernel_artifacts().await?
            }
        };

        let config_bundles = futures::stream::iter(kernel_artifacts.into_iter())
            .filter_map(|kernel| async move {
                kernel
                    .extract_cryptpilot_files()
                    .await
                    .map(|(fde_config_bundle, _)| fde_config_bundle)
                    .map_err(|error| {
                        tracing::warn!(
                            ?error,
                            "Failed to load fde config bundle or root_hash from initrd, skip now"
                        );
                    })
                    .ok()
            })
            .collect::<Vec<_>>()
            .await;

        if config_bundles.len() > 1 {
            tracing::warn!("More than one fde config bundle found, will print the first one only")
        }

        let fde_config_bundle = config_bundles
            .into_iter()
            .next()
            .ok_or_else(|| anyhow::anyhow!("No fde config bundle found"))?;

        let hash_hex = fde_config_bundle.gen_hash_hex()?;
        let hash_content_pretty = fde_config_bundle.gen_hash_content_pretty()?;

        println!(
            r#"{CLOUD_INIT_FDE_CONFIG_BUNDLE_HEADER}

# This config is generated by cryptpilot. And you can also put this cloud-init user data of your instance
#
# The sha384 hash of this config is: {hash_hex}


{hash_content_pretty}"#
        );
        Ok(())
    }
}
